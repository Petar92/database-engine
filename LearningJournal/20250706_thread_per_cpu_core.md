# Journal Entry - July 6th, 2025

It's been a while since I last upddated this journal but I've been busy with work and the current situation in my country that I have taken active part in (student-led protests in Serbia).

Anyhow, I have finished reading the book and I've been reading some articles and documentation on different topic related to database internals and c++. One thing that came to my mind is to avoid concurrency by using a single thread per db core, this way I would avoid take advantage of parallelism and avoid pitfalls of concurrency. I started researching if anyone is doing something like this and I found that [ScyllaDB does this](https://www.scylladb.com/product/technology/shard-per-core-architecture/). I felt very proud of myself for coming up with this. However, my idea differs in the sense that I wanted to shard per thread in the way that groups a certain amount of db pages (depending on the number of available cores) just like ScyllaDB does, but instead of assigning all requests to an initial shard and then routing them to appropriate shards using message passing, I wanted to immidiately route the incoming request to the appropriate shard. But this is an isssue because I need to parse the request first in order to determine which shard to route it to and that means I wouldn't be able to make it work as I wanted, to immeditaley route the request to the appropriate shard. So I came up with an idea to parse the request on the client side and send it to the server that will then immidiately know where to route it to. I checked if any database does this and, of course, found that some databases do this, such as EdgeDB, ClickHouse, MongoDB, etc. But my idea differs from these as I want to parse it to determine the type of request, e.g. if it is a query to use a database (USE DATABASE_NAME) or if it is a query to create a table (CREATE TABLE_NAME), or maybe to perform select, insert, update, etc. I will need to do reaserch in order to define query groups and once I do that, send it as a parameter to the server as well as other information about the query. Maybe the best way to ilustrate this is to use an example. Let's say I want to perform the follwing query: `SELECT * FROM Users`. The client will parse this and determine that this is a query on a known database that had to have been chosen in a previous query, then it would determine that it needs to fetch data from the table `Users` and it will send this information to the server. Immidiately the server will, based on a mechanism that is yet to be defined, know that information about table `Users` is stored in shard 1 and it will route the request to shard 1.

With this in mind I finally started doing some practical work. So I need a thread per core. From my previous readings, I know how to create a thread, what to watch out for, how to get the number of cores for the machine. I did not know how to bind a thread to a cpu core. It didn't take a lot of research to find this and there are different way to do this for unix based systems and windows. Since it would be too broad to take both routes right now and I have already wasted a lot of time I decided to only do this for uinx based systems. I found this [link](https://man7.org/linux/man-pages/man3/pthread_setaffinity_np.3.html) that documents the pthread_setaffinity_np() function and since the documentation is pretty straight forward I won't be going into details. I have updated my process pool class and the next step is to implement the client as I have already defined above. 

Stay tuned for more updates...